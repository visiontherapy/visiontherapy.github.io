<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Letter Tracking</title>
  <meta name="darkreader-lock" />

  <link rel="stylesheet" href="vision.css" />
  <script defer src="settings.js"></script>

  <style>
    #output {
      font-size: 25pt;
      margin: 1.5em 2em;
      line-height: 1.5em;
      letter-spacing: 0.1ex;
      cursor: default;
    }



    #showsolution:checked~#output {
      .selected {
        color: red;
        text-decoration: line-through;
        /* incorrect selection*/
      }

      .alpha {
        color: red;
        /* missed letter */
        text-decoration: underline;


        &.selected {
          color: green;
          /* correct selection */
        }
      }
    }

    #output span.selected {
      color: aqua;
      /* default selection */
    }


    .wordcount {
      opacity: 0;
      cursor: default;
    }

    .wourdcount:hover {
      opacity: 1;
    }


    #output span {
      border: solid 1px var(--bg);
      display:inline-block;

    }

    #output span:hover {
      border: solid 1px var(--fg);
    }
  </style>
</head>

<body>
  Wordbank:
  <textarea id="wordbank">th to ts te ti tu tc ta ty tl tt tr tw tg he hi ha ho ht hu hr hy er em ea el en ed ee et ev ef ei eh ex ew es eq eg ey ec ep ek eo ez eb re ry rk ra rw rd rr ri rt ro rn rg rm rs rv ru rc rh rl rp wa wh wo wi wn wr we wd as ar ab at al ay af av ac ai an ad ak am ag ap au ax no ng nk nd na ne ni nt nc ns nn ny nv nl nu nf ot or ou of oh ov oc on oo ok oa os op ow ol om og od oe ob ox in id ic it is im ie io iv ix ia ig ir if ip iq il ib so sa se sh st ss si su sl sp sc sm sk sq ve vo vi ma mu me mi mo my mp mb ms ka ke ks ki bl bb bi be bu bo by bj ba br le li lf ll la ly lo ld lm ls lu lt lk lw lv di de ds do dg da dy dd dm dr dv dl du df ce ch cc cu ct co ck cr cl ca ci cq uc ut ug ur ui ua un us ue ud um up ul ub gh ge gu gi ga gr go gn ft fe fo fl fi ff fa fu fr qu po pu pr pa pe pi pl ps pp ph pt ju je ys yi yl ye yt yw xc xe xy zo ze </textarea>
  <button id="go">go</button>
  <br />
  <button id="reload">New Chart</button>

  <input type="checkbox" class="slider"  id="darkmode" /><label class="button" for="darkmode">Dark mode</label>
<br/>
  <input type="checkbox" id="startstop" />
  <label class="button" for="startstop">start</label>
  <span id="timer"></span>
<br/>
  <input type="checkbox" class="slider" id="showsolution" />
  <label class="button" for="showsolution">Show Solution</label>
  <div id="output"></div>

  <script>
    let digraphs = {};
    let alphabet = "abcdefghijklmnopqrstuvwxyz";
    let missing;


    document.querySelector("#go").onclick = function () {
      getdigraphs();
      showchart();
    };

    document.querySelector("#reload").onclick = function () {
      showchart();
    };

    getdigraphs();
    showchart();


    // need to check that all letters are represented in wordbank


    function getdigraphs() {
      let words = document.querySelector("#wordbank").value.replace(/[^\w\s]/g, " ").toLowerCase();

      missing = [];
      for (const ltr of alphabet.split("")) {
        if (!words.match(new RegExp(ltr))) {
          missing.push(ltr);
        }
      }
      if (missing.length > 0) {
        digraphs = {};
        return;
      }
      console.log(missing);



      for (let word of words.split(/\s+/)) {
        let sword = word.split("");
        let letters = [];
        for (let c = 0; c < sword.length; c++) {
          letters.push(sword[c]);
          if (letters.length == 2) {
            // check if current digraph exists in the digraph bank
            let digr = letters.join("");
            //console.log(digr);

            if (typeof digraphs[letters[0]] === "undefined") {
              digraphs[letters[0]] = { [letters[1]]: 1 };
            } else if (typeof digraphs[letters[0]][letters[1]] === "undefined") {
              digraphs[letters[0]][letters[1]] = 1;
            } else {
              digraphs[letters[0]][letters[1]]++;
            }
            letters.shift(); // only keep 2 letters in array = digraphs
          }
        }
      }

      // console.log(digraphs);

      //** This section is for debugging only
      //** replace wordbank text with flatdigraphs to make it more concise
      // let flatdigraphs = "";
      // for (const prima of Object.keys(digraphs)) {
      //   for (const secund of Object.keys(digraphs[prima])) {
      //     flatdigraphs += prima + secund + " ";
      //   }
      // }
      // console.log(flatdigraphs);


    }


    let timer = document.querySelector("#timer");
    let startbtn = document.querySelector("#startstop");
    let startstop;
    startbtn.onchange = function () {
      document.querySelector("#startstop+label").innerHTML = this.checked ? "stop" : "start";
      if (this.checked) {
        let zerotime = (new Date()).getTime();
        startstop = setInterval(() => {
          let timediff = (new Date()).getTime() - zerotime;
          console.log(timediff);
          document.querySelector("#timer").innerText = mstotime(timediff);
        }, 100);
      } else {
        clearInterval(startstop);
      }

    };



    //https://bobbyhadz.com/blog/javascript-convert-milliseconds-to-hours-minutes-seconds

    function pad2start(num) {
      return num.toString().padStart(2, '0');
    }

    function mstotime(milliseconds) {
      let seconds = Math.floor(milliseconds / 1000);
      let minutes = Math.floor(seconds / 60);
      let hours = Math.floor(minutes / 60);

      let millis = Math.floor(milliseconds % 1000 / 100);
      seconds = seconds % 60;
      minutes = minutes % 60;
      // hours = hours % 24; // roll over hours every 24 

      return `${pad2start(hours)}:${pad2start(minutes)}:${pad2start(seconds)}.${millis}`;
    }



    function showchart() {
      // console.log(digraphs.length>0,digraphs); return;

      if (Object.keys(digraphs).length == 0) {
       document.querySelector("#output").innerText = "Word bank is incomplete. The following letters are missing: " + missing.join(", ") + ".";
        // console.log("bad digraph collection", digraphs);
        return;
      }
      document.querySelector("#showsolution").checked = false;

      let maxwords = 100;

      let wordmin = 3;
      let wordmax = 5;

      let alpha = (alphabet + "#").split("");
      let alphaorder = alphabet.split("");
      let clickalpha = (alphabet).split("");

      let sequence = "";
      let string = "";
      let wordlength = wordmin + Math.floor(Math.random() * (wordmax - wordmin + 2));
      let wordcount = 0;

      while (wordcount < maxwords) {
        let newltr = getchar(sequence);
        let alphatype = "";
        if (alphaorder.length > 0 && newltr == alphaorder[0]) {
          // if newltr is in alphabetical order, cross it off the list
          alphaorder.shift();
          alphatype = "alpha"; // add class for cheat code
        }

        sequence += newltr;
        string += `<span class="${alphatype}">${newltr}</span>`;;
        //console.log(sequence.length, wordlength, sequence.length%wordlength);
        if (sequence.length == wordlength) {
          string += " ";
          sequence = "";
          wordlength = 3 + Math.floor(Math.random() * 3);
          wordcount++;
        }

        if (wordcount == maxwords && alphaorder.length > 0) {
          console.log("maxed out");// alphaorder);
          // need more words to complete the sequence
          wordcount -= alphaorder.length;
        }
      }

      // finally display chart
      document.querySelector("#output").innerHTML = string + "<span class='wordcount'>" + string.split("> <").length + "</span>";

      document.querySelector("#output").onclick = function (e) {
        console.log(e.target.innerText);

        if (e.target.classList.contains("selected")) {
          e.target.classList.remove("selected");
        } else {
          e.target.classList.add("selected");
        }
        // if (e.target.innerText == clickalpha[0]) {
        //   e.target.style.color = "aqua";
        //   clickalpha.shift();
        // }
      };



      function getchar(sequence = "") {
        let chr = alpha[Math.floor(Math.random() * alpha.length)];
        let prevchr = sequence ? sequence.match(/.$/)[0] : "";

        if (chr == "#") { //27th "letter" => ensure alpha order
          chr = alphaorder[0]; //alphaorder.push(alphaorder.shift());
        }

        /*
          if (prevchr == chr) {
            getchar();
          } else */
        if (!prevchr && digraphs[chr]) {
          return chr;
        }

        if (!digraphs[prevchr]) {
          console.log("no digraph with this start", prevchr);
          return "";
          //return getchar(sequence);
        }

        if (digraphs[prevchr] && digraphs[prevchr][chr]) {
          //console.log("OK:", prevchr + chr);
          return chr;
        }

        //console.log("were here", prevchr,chr);
        return getchar(sequence);

      }
    }

  </script>

</body>

</html>