<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hart Chart exercise</title>
  <meta name="darkreader-lock">
  <link rel="stylesheet" href="vision.css" />
  <script src="settings.js"></script>
  <style>
    #tapp {
      cursor: pointer;
      display: inline-block;
      padding: 0.1em;
      border: solid 1px green;
      user-select: none;
    }

    #tapp:active {
      border-color: red;
    }

    #bpm {
      width: 3em;
      margin-left: 0.5em;
    }

    #main {
      height: min(85vh, 85vw);
      width: min(85vh, 85vw);
      top: clamp(2.5rem,2.5em,10vh);
      display: grid;
      grid-template-columns: repeat(10, 1fr);
    }

    .slot {
      position: relative;
      text-align: center;
    }

    #qrplace {
      display: block;
      position: fixed;
      left: 50%;
      transform: translate(-50%);
      top: 0.5em;
    }

    .qrcode {
      display: none;
      padding: 10px;
      background: #fff;
      position: absolute;
      left: 50%;
      transform: translate(-50%);
      top: 1.5em;
    }

    #qrtoggle:checked~.qrcode {
      display: block;
    }
  </style>
  <!-- https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/ -->
  <!-- https://dev.to/murtuzaalisurti/how-to-make-a-qr-code-generator-using-vanilla-javascript-3cla -->
  <script src="qrcode.min.js"></script>
</head>

<body>

  <div id="main" data-mark="">
  </div>

  <!-- TODO
  QR code for mobile app to show mini version
 -->

  <div id="controls">
    <div id="settings">*SETTINGS*</div>

    <div><input type="checkbox" class="slider" id="darkmode" checked="checked" /><label for="darkmode">Dark mode</label></div>
    <button id="metronome">metronome</button><br />
    <div id="tapp">TAP</div><input type="text" id="bpm" /><br />

  </div>
  <button id="reload">Reload</button>

  <div id="qrplace"></div>

  <script>


    // let blip = new Audio("click.wav");
    let bpm = 60;

    let metronome;


    document.querySelector("#bpm").oninput = function () {
      console.log(this.value);
      bpm = parseInt(this.value);
    };

    /* 
    TODO: 
    metronome on/off by spacebar
    set BPM by slider / text
    set bpm by tapping
https://web.dev/articles/audio-scheduling

TRY THIS ONE INSTEAD
https://ircam-ismm.github.io/webaudio-tutorials/scheduling/timing-and-scheduling.html

    */

    let lasttime = 0;
    let actx, g;
    let beatcount = 10;
    let beats = [];
    let tappinterval;
    let beatsavg;
    document.querySelector("#tapp").onmousedown = function (e) {

      console.log(tappinterval);
      clearbeeps();
      beep();
      let interbeat = actx.currentTime - lasttime;
      lasttime = actx.currentTime;
      if (interbeat > beatsavg * 3) {
        console.log("clearing beats");
        beats = [];
        interbeat = 0;
      }
      if (interbeat) beats.push(interbeat);
      if (beats.length > beatcount) beats.shift();
      let beatsum = 0;
      beats.map(n => beatsum += n);
      beatsavg = beatsum / beats.length;
      // console.log(beats, beatsum, beats.length, beatsavg);
      bpm = document.querySelector("#bpm").value = interbeat ? Math.round(60 / beatsavg) : "--";
      //console.log("Beatsavg",beatsavg);
      if (beatsavg > 0) {
        tappinterval = setTimeout(() => {
          dometronome(beatsavg > 0);
          console.log("metronoming");
        }, beatsavg * 1000);
      }
    };


    function clearbeeps() {
      if (metronome) clearInterval(metronome);
      if (tappinterval) clearTimeout(tappinterval);
      tappinterval = metronome = null;

    }


    function beep(dobeep = true) {
      if (!actx) actx = new AudioContext();
      if (!g) g = actx.createGain();
      osc = actx.createOscillator();
      osc.frequency.value = 700;
      let defgain = 0.5;
      g.gain.value = defgain;
      osc.connect(g);
      g.connect(actx.destination);
      if (dobeep) {
        console.log("beeping");
        osc.start(actx.currentTime);
        g.gain.setTargetAtTime(0, actx.currentTime + 0.01, 0.07,);
        osc.stop(actx.currentTime + 0.1);
        g.gain.setTargetAtTime(defgain, actx.currentTime + 0.15, 0);
      }
    }


    document.querySelector("#metronome").onclick = function () {
      if (metronome) {
        console.log("clearing");
        clearbeeps();
      } else {

        dometronome();
      }
      //metronome = !metronome;
    };


    function dometronome(firstbeep = true) {
      beep(firstbeep);
      //https://loophole-letters.vercel.app/web-audio-scheduling#built-in-web-audio-scheduling-methods
      let phase = actx.currentTime;
      // bpm = 
      console.log("BPM", bpm);
      const period = 0.5; // schedule period in seconds
      const overlap = 0.25; // margin for errors

      let interval = 60 / bpm;
      function metronomecallback() {
        // https://stackoverflow.com/questions/15091059/change-interval-of-setinterval
        // do this so that interval can be updated with each go around...?
        interval = 60 / bpm;
        // time slice for this callback:
        const lookahead = actx.currentTime + interval + overlap;
        // step through each slice of time for this callback
        while (phase < lookahead) {
          const [begin, end] = [phase, phase + period];
          // console.log(begin, end, interval);
          beep();
          break;
          phase += period;
        }
        metronome = setTimeout(metronomecallback, interval * 1000);
      }
      metronome = setTimeout(metronomecallback, interval * 1000);
    }




    function newjitterydometronome() {

      beep(false);
      function metro(currentTime) {
        console.log(currentTime);
        // play some sound at `currentTime`
        beep();
        // return the next time we want to do something
        return currentTime + 60 / bpm;
      }

      // create a new LookaheadScheduler
      const scheduler = new LookaheadScheduler();
      // add the metronome to the scheduler, starting now
      scheduler.add(metro, actx.currentTime);
      metronome = scheduler.ticker;

    }


    class PriorityQueue {
      constructor() {
        // array in which we store the elements of the queue
        this.queue = [];
      }

      // add an event with its associated priority into the queue
      add(event, time) {
        // pack `event` and `time` into a single data structure
        const element = { event, time };
        // add the data structure into the queue
        this.queue.push(element);
        // sort the queue so that the element with highest priority (i.e. smallest time)
        // is at the beginning of the list
        this.queue.sort((a, b) => a.time <= b.time ? -1 : 1);
      }

      // return the event with highest priority or `null` if the queue is empty
      head() {
        if (this.queue.length > 0) {
          return this.queue[0];
        } else {
          return null;
        }
      }

      // delete the first element of the queue
      deleteHead() {
        this.queue.shift();
      }
    }


    class LookaheadScheduler {
      constructor() {
        this.priorityQueue = new PriorityQueue();
        this.period = 0.05;
        this.lookahead = 0.1;

        // make sure the tick method is called with the right `this` context,
        // whatever its call context (welcome to JavaScript :)
        this.tick = this.tick.bind(this);
        // launch the periodic `tick` call
        this.ticker = setInterval(this.tick, this.period * 1000);
      }

      add(event, time) {
        // insert the event, time pair into the queue
        this.priorityQueue.add(event, time);
      }

      // This function is executed by the `setInterval` every 50 ms.
      // This is where all the magic happens
      tick() {
        // get the current time of the audio context and the current head of the queue
        const now = actx.currentTime;
        let head = this.priorityQueue.head();

        // unstack the queue while the head is in the time frame defined by the lookahead
        while (head && head.time < now + this.lookahead) {
          // the head will be processed so we can remove it from the queue
          this.priorityQueue.deleteHead();
          // pick the time and event from the head
          // the time of the event is not `now`, it is somewhere between now and now + lookahead
          const time = head.time;
          const event = head.event;

          // Execute the event giving it its time as argument.
          // If the event returns a new time, i.e. it wants to be called again later,
          // we can re-insert it right away into the queue.
          const nextTime = event(time);

          if (nextTime) {
            this.priorityQueue.add(event, nextTime);
          }

          // pick the next event in the queue and check if it is in the lookahead
          head = this.priorityQueue.head();
        }
      }
    }



    let main = document.querySelector("#main");


    // const params = new URLSearchParams(window.location.search);

    // let querypattern = params.get("q");
    // console.log(params);
    let querypattern = window.location.hash.replace(/^#/, "");
    querypattern = querypattern.toUpperCase().replace(/[^A-Z]/g, "");
    if (querypattern) {
      // querypattern = 
      showchart(querypattern.split(""));
    } else {
      showchart();
    }



    function showchart(pattern) {
      let txferstring = "";
      main.innerHTML = "";
      let lastchar = "";
      for (let x = 0; x < 10; x++) {
        for (let y = 0; y < 10; y++) {
          let slot = document.createElement("div");
          slot.className = "slot";
          let breakcount;
          // while (nextchar == lastchar) {
          slot.innerText = lastchar = pattern ? pattern.shift() : nextletter(lastchar);
          txferstring += lastchar;
          main.append(slot);
        }
      }

      // return txferstring;
      // if (!pattern) {
      let url = window.location.toString();
      url.replace(/[\?#&].*$/, "");
      let qrstring = url + "#" + txferstring;
      console.log(qrstring);
      getqr(qrstring);
      // }

    }

    function getqr(data) {
      let [w, h] = [250, 250];
      let qrplace = document.querySelector("#qrplace");
      let qrcode = document.createElement("a");
      qrcode.className = "qrcode";
      qrcode.href = data;
      // qrcode.style = `padding:10px;background:#fff;position:absolute;left:50;top:1em;`;
      // let theqrcode = 
      new QRCode(qrcode, {
        text: data,
        width: w,
        height: h,
        colorDark: "#000",
        colorLight: "#fff",
        correctionLovel: QRCode.CorrectLevel.L,
      });
      // console.log(qrcode);


      // input type="checkbox" class="slider" id="darkmode" checked="checked" /><label for="darkmode">Dark mode</label>
      qrplace.innerHTML = `<input type="checkbox" class="slider" id="qrtoggle" /><label for="qrtoggle">QR code</label>`;
      qrplace.append(qrcode);
    }




    function nextletter(lastchar) {
      let alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      let loopcount = 0;
      let nextchar;
      do {
        nextchar = alpha[Math.floor(Math.random() * alpha.length)];
        // console.log("checking mark",loopcount,nextmark,centerpoint.dataset.mark);
        if (++loopcount > 5) break; // prevent infinite loop when only one mark is available
      } while (nextchar && nextchar == lastchar);
      return nextchar;
    }


    document.querySelector("#reload").onclick = function (e) {
      showchart();
      window.location.hash="";
    };


  </script>

</body>

</html>